# 참조
chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://gpwsirsa.edu.in/wp-content/uploads/2023/03/Java.pdf


# 배열
---
### **1. 역사**

배열은 컴퓨터 과학이 발전함에 따라 다양한 형태로 확장되었습니다. 예를 들어, 다차원 배열, 동적 배열, 연관 배열 등 다양한 형태의 배열이 현대 프로그래밍 언어에 도입되었습니다.

따라서 배열은 특정 개인에 의해 "발명"되었다기보다는, 컴퓨터 과학이 발전하면서 여러 학자와 프로그래머들에 의해 자연스럽게 개발되고 정립된 개념입니다. 초기 컴퓨터 과학자들, 특히 Fortran과 Algol과 같은 초기 언어를 개발한 사람들은 배열의 개념을 도입하고 확립하는 데 중요한 역할을 했습니다.

배열(Array)은 자바의 초기버전 부터 언어의 표준 자료 구조로 포함되어 있었습니다.



### **1. 배열이란?**
배열(Array)은 프로그래밍에서 데이터를 효율적으로 관리하고 접근하기 위해 만들어진 가장 기본적인 자료 구조입니다. 배열은 생성 시 고정된 크기를 가지며, 연속된 메모리 공간에 데이터를 저장합니다. 인덱스를 통해 배열의 각 요소에 접근할 수 있습니다. 

### **1.1. 특징**

- **연속된 메모리 할당:** 배열은 연속된 메모리 공간에 데이터를 저장합니다. 이렇게 함으로써 각 요소에 대한 접근이 빠르고 효율적으로 이루어질 수 있습니다. 배열의 요소들은 인덱스를 통해 접근되므로, 특정 위치의 데이터를 읽거나 쓰는 작업이 매우 빠릅니다.

- **정해진 크기:** 배열은 고정된 크기를 가지며, 생성 시 필요한 메모리 공간을 한 번에 할당합니다. 이는 메모리 관리 측면에서 효율적이며, 메모리 공간을 예측 가능하게 만듭니다.

- **고정된 크기:** 배열은 생성 시 크기가 결정되며, 한 번 생성된 배열의 크기는 변경할 수 없습니다.

- **동일한 데이터 타입:** 배열의 모든 요소는 동일한 데이터 타입을 가져야 합니다.

- **인덱스 접근:** 배열의 각 요소는 인덱스를 통해 접근할 수 있습니다. 인덱스는 0부터 시작합니다. **예) 사이즈 5의 크기를 지닌 배열의 마지막 인덱스는 4가 되는 셈**

- **다차원 배열:** 자바에서는 1차원 배열뿐만 아니라 2차원, 3차원 등 다차원 배열도 생성할 수 있습니다.

### **1.2. 코드 설명**
```
       // 크기가 5인 고정된 정수형 배열 생성
        int[] numbers = new int[5];

        // 배열에 값 할당
        numbers[0] = 10;
        numbers[1] = 20;
        numbers[2] = 30;
        numbers[3] = 40;
        numbers[4] = 50;
```
![image](https://github.com/user-attachments/assets/a2ace836-e032-4dc3-a213-d9af0e10cde8)


- Java에서 int 자료형은 4바이트(32비트)를 차지합니다.

- **메모리에 저장된 크기:** 5×4 bytes=20 bytes





### **2. 배열과 메모리 **

### **2.1. 사진 설명**
```
        // 기본형 int 생성
        int number = 10;
        // 배열 생성
        int[] numbers = new int[5];

        // 배열에 값 할당
        numbers[0] = 10;
        numbers[1] = 20;
        numbers[2] = 30;
        numbers[3] = 40;
        numbers[4] = 50;
```


![image](https://github.com/user-attachments/assets/6b1ca511-72e6-4c9f-bccb-e2e6af6e8211)



기본형(primitive type)은 변수(number) 자체가 값(10)을 저장하므로 Stack 영역에 저장됩니다.
배열은 new 연산자를 사용하므로 참조형(reference type)으로 분류되며 객체를 Heap에 저장하고 변수(numbers)는 stack에 저장됩니다.

### **2.2.결론**

new 연산자: Java에서 new 연산자를 사용하여 생성되는 모든 것은 객체로 간주되며, 객체는 Heap 메모리에 저장됩니다. 배열도 이 규칙을 따르기 때문에 new 연산자를 사용하여 생성된 배열은 객체로 간주되어 Heap에 저장됩니다.

따라서, int 같은 기본형 데이터 타입은 Stack에 직접 저장되지만, int[] 배열은 객체로서 Heap에 저장되며, 배열의 참조는 Stack에 저장됩니다.



### **2.3.(번외) 배열크기가 고정인 이유**

배열의 길이를 변경할 수 없는 이유는 배열을 저장할때 메모리에서 연속된 블록으로 저장되기 때문입니다. 이를 그림과 설명으로 자세히 설명하겠습니다.


![image](https://github.com/user-attachments/assets/ed12c6d2-78b0-4fc1-891e-dbd2d95f3436)

person 객체를 생성해 Heap 메모리에 할당 후 크기가 5인 int 배열 numbers를 생성하여 위 그림과 같이 메모리에 딱 5의 크기만큼의 공간에 할당이 되었다고 가정 하겠습니다.
이제, numbers 배열의 크기를 늘리려고 한다면(예: 크기 5에서 크기 10으로), 기존 메모리 블록이 Person 객체에 가로막혀 추가적인 요소를 수용할 수 없다면, 다음과 같은 과정이 발생합니다:

새로운 메모리 공간 할당: 더 큰 배열을 수용할 수 있는 충분히 연속된 메모리 블록을 찾아야 합니다. 기존 배열 바로 뒤에 충분한 공간이 없을 수 있기 때문에, 메모리 할당자는 힙의 다른 곳에 새로운 연속된 메모리 블록을 할당해야 합니다.

데이터 복사: 기존 배열의 모든 요소를 새로운 메모리 공간으로 복사해야 합니다.

참조 업데이트: 기존 배열을 참조하던 모든 참조를 새로운 배열로 업데이트해야 합니다.

person 객체를 생성 후 힙메모리에 저장이 되고 그 후 크기가 5인 int 형 numbers 라는 변수를 가진 배열을 저장할때 person 객체 바로 뒤에 저장이 되었을때 만약 numbers 배열의 크기를 늘리려면 다른 저장공간을 찾아야하는 번거로움이 있으면 성능저하로 이어져서 그래?
1. 연속된 메모리 할당
배열은 메모리에서 연속된 공간을 차지합니다. 예를 들어, int[5] 배열을 선언하면, 메모리에서 연속된 20바이트(5개의 int × 4바이트)가 할당됩니다.
배열의 길이를 변경하려면, 기존에 할당된 메모리 블록을 확장하거나 축소해야 하는데, 이는 메모리 구조상 어렵고 비효율적입니다. 특히, 할당된 메모리 블록 바로 뒤에 다른 데이터가 있을 경우, 배열을 확장하는 것이 불가능해질 수 있습니다.
2. 고정된 메모리 크기
배열의 크기는 배열이 생성될 때 고정되며, 이 크기는 배열이 존재하는 동안 변경되지 않습니다. 이는 메모리 관리 측면에서 효율성을 높입니다. 크기가 고정된 배열은 인덱싱 및 메모리 접근이 빠르고 일정하게 이루어질 수 있습니다.
만약 배열의 크기를 동적으로 변경할 수 있게 한다면, 기존 배열의 데이터를 새로운 크기의 배열로 복사해야 하고, 그 과정에서 많은 메모리 연산이 필요하게 됩니다. 이는 성능에 큰 영향을 미칠 수 있습니다.
3. 참조 안정성
배열의 크기가 고정되어 있기 때문에, 배열을 참조하는 다른 코드들이 배열의 크기가 변하지 않음을 신뢰할 수 있습니다. 예를 들어, 배열의 크기가 갑자기 변하면, 이미 배열을 참조하고 있던 코드들이 예상치 못한 오류를 발생시킬 수 있습니다.

