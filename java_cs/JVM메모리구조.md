# JVM의 메모리 구조
---
JVM (Java Virtual Machine)은 애플리케이션이 실행되는 동안 메모리를 관리하고 사용할 수 있도록 동작하는 구조입니다. 애플리케이션 실행 시 OS로부터 메모리를 동적으로 할당받습니다. 이 메모리는 JVM이 시작될 때 할당되고, 애플리케이션의 실행 과정에서 필요에 따라 확장되거나 축소될 수 있습니다. 예를들어 객체 생성이나 큰 배열의 선언 시 JVM은 OS(RAM)에 추가적인 메모리를 요구하여 필요에 따라 유동적으로 관리를 합니다.

### **1. 변수의 범위(scope)와 생명주기(lifetime)**
먼저 변수의 범위 부터 알아 보겠습니다. 변수의 범위에 따라 할당되는 메모리 영역과 생명주기가 다름으로, 좀 더 구체적으로 알아보기 위해 종류와 범위에대해 파악해 보겠습니다.

![image](https://github.com/user-attachments/assets/c6a7b53c-8ccd-437b-b823-0453b84f3b80)

<br><br>

<table>
  <tr>
    <th>변수 종류</th>
    <th>선언 위치</th>
    <th>생성 시기</th>
  </tr>
  <tr>
    <td>클래스 변수 (class variable)</td>
    <td rowspan="2">클래스 영역</td>
    <td>클래스가 메모리에 올라갈 때</td>
    
  </tr>
  <tr>
    <td>인스턴스 변수 (instance variable)</td>
    <td>인스턴스(객체)가 생성되었을 때 </td>
  </tr>
  <tr>
    <td>매개변수 (parameter)</td>
    <td>메소드, 생성자 영역</td>
    <td>해당 메소드나 생성자가 호출될 때</td>
  </tr>
   <tr>
    <td>지역 변수 (local variable)</td>
    <td>클래스 영역 이외의 영역</td>
    <td>변수 선언문이 수행되었을 때</td>
  </tr>
</table>

참조: https://www.youtube.com/watch?v=qA0D-nAcAvQ&list=PLW2UjW795-f6xWA2_MUhEVgPauhGl3xIp&index=57


# Java 메모리와 변수

## 1. 변수 개요

### **1.1 인스턴스 변수 (Instance Variable)**
- **설명**: 클래스의 인스턴스(객체)가 생성될 때 함께 생성되는 변수로, 객체의 상태를 저장합니다.
- **특징**:
  - 인스턴스마다 독립적으로 존재합니다.
  - 클래스 내에서 선언되며, 객체가 메모리에서 해제될 때 함께 소멸됩니다.

### **1.2 클래스 변수 (Static Variable)**
- **설명**: 클래스에 속하는 변수로, 클래스가 메모리에 로드될 때 한 번만 생성되며 모든 인스턴스가 이 변수를 공유합니다.
- **특징**:
  - `static` 키워드로 선언됩니다.
  - 프로그램이 종료될 때까지 존재합니다.

### **1.3 지역 변수 (Local Variable)**
- **설명**: 메소드나 블록 내에서 선언되며, 해당 메소드나 블록이 실행되는 동안에만 존재하는 변수입니다.
- **특징**:
  - 메소드가 종료되면 메모리에서 소멸되며, 다른 메소드에서는 접근할 수 없습니다.

### **1.4 매개 변수 (Parameter)**
- **설명**: 메소드나 생성자가 호출될 때 전달받은 값을 저장하는 변수입니다.
- **특징**:
  - 해당 메소드나 생성자의 지역 변수로 간주되며, 호출이 끝나면 소멸합니다.

## 2. JVM 메모리 구조

### **2.1 메소드 영역 (Method Area)**
- **설명**: JVM이 시작될 때 생성되는 메모리 영역으로, 모든 스레드가 공유합니다. 이 영역에는 클래스, 인터페이스, 메소드, 필드, 상수 풀과 같은 메타데이터가 저장됩니다.
- **역할**: 클래스의 구조, 메소드의 코드 등을 저장하며, JVM이 클래스를 로드하고 해석할 때 이 정보를 사용합니다.

### **2.2 힙 (Heap)**
- **설명**: 모든 스레드가 공유하는 영역으로, JVM에서 가장 큰 메모리 영역입니다. 힙 영역에는 모든 객체와 배열이 동적으로 할당됩니다.
- **역할**: 객체의 인스턴스가 생성되고, GC(Garbage Collection)가 이 영역에서 사용하지 않는 객체를 정리합니다.
- **세분화**:
  - **Young Generation (Young 영역)**: 새롭게 생성된 객체가 저장되며, 상대적으로 크기가 작고, 이 영역에서 GC가 빈번하게 발생합니다.
    - **Eden Space**: 처음 객체가 생성되는 공간.
    - **Survivor Space**: GC 후 살아남은 객체가 옮겨지는 공간. 보통 두 개의 Survivor 공간으로 나뉘며, 하나는 활성화된 상태이고 다른 하나는 비활성화 상태입니다.
  - **Old Generation (Old 영역)**: Young Generation에서 오래 살아남은 객체가 이 영역으로 옮겨지며, GC가 덜 빈번하게 발생합니다.

### **2.3 스택 (Stack)**
- **설명**: 각 스레드마다 독립적으로 존재하는 영역입니다. 메소드 호출 시 생성되며, 메소드의 호출과 관련된 정보(지역 변수, 매개변수, 리턴 주소 등)가 저장됩니다.
- **역할**: 메소드의 실행을 지원하며, 메소드가 종료되면 해당 스택 프레임은 자동으로 제거됩니다.
- **구성 요소**:
  - **프레임 (Frame)**: 각 메소드 호출마다 하나의 프레임이 생성되며, 지역 변수, 연산 스택, 상수 풀에 대한 참조 등을 포함합니다.

### **2.4 프로그램 카운터 레지스터 (PC Register)**
- **설명**: 각 스레드마다 존재하는 영역으로, 현재 실행 중인 JVM 명령의 주소를 저장합니다.
- **역할**: 현재 실행 중인 명령의 위치를 추적하며, 명령어 실행 후 다음 명령으로 이동할 수 있도록 합니다.

### **2.5 네이티브 메소드 스택 (Native Method Stack)**
- **설명**: Java가 아닌 다른 언어(C, C++)로 작성된 네이티브 코드를 실행할 때 사용되는 스택입니다.
- **역할**: 네이티브 메소드 호출 시 이 스택이 사용되며, 해당 메소드의 정보를 저장합니다.

### **2.6 실행 엔진 (Execution Engine)**
- **설명**: JVM의 핵심 부분으로, 바이트코드를 해석하고 실행합니다.
- **구성 요소**:
  - **인터프리터 (Interpreter)**: 바이트코드를 하나씩 읽어 해석하고 실행합니다.
  - **JIT 컴파일러 (Just-In-Time Compiler)**: 자주 사용되는 바이트코드를 네이티브 코드로 변환하여 성능을 향상시킵니다.
  - **Garbage Collector (GC)**: 사용되지 않는 객체를 자동으로 메모리에서 해제합니다.

### **2.7 네이티브 메소드 인터페이스 (JNI)**
- **설명**: Java 코드와 네이티브 코드 간의 상호작용을 위한 인터페이스입니다. JNI를 통해 Java 코드에서 네이티브 메소드를 호출할 수 있습니다.

## 3. 실무에서의 성능 최적화 고려사항

### **3.1 스택 메모리와 성능**
- **특성**: 스택 메모리는 메서드 호출 시 할당되고, 메서드가 종료되면 자동으로 해제됩니다. 스택에서의 메모리 할당과 해제는 매우 빠르기 때문에 일반적으로 성능 병목이 되지 않습니다.
- **스택 메모리 크기**: 현대의 JVM에서 스택 메모리 크기는 기본적으로 충분히 크며, 일반적인 애플리케이션에서 스택 메모리 부족으로 문제가 발생하는 경우는 드뭅니다.

### **3.2 `byte`와 같은 작은 타입 사용**
- **작은 타입 사용**: `byte`, `short`, `int` 등의 원시 타입(primitive type)을 선택하는 것은 주로 메모리 절약보다는 코드의 명확성과 의미 전달을 위한 목적이 큽니다. 성능 향상은 대부분의 경우 미미합니다.
- **컴파일러 최적화**: 대부분의 현대 JVM과 컴파일러는 원시 타입의 크기 차이로 인한 성능 차이를 거의 없도록 최적화되어 있습니다.

### **3.3 실무에서의 최적화 포인트**
- **객체 생성 최소화**: 스택 메모리보다는 힙 메모리 사용을 줄이는 데 더 많은 관심을 기울입니다. 불필요한 객체 생성을 줄이거나 객체 풀링(object pooling) 기법을 사용해 메모리 사용을 최적화합니다.
- **메모리 프로파일링**: 메모리 사용 패턴을 분석하고, 필요에 따라 최적화하기 위해 메모리 프로파일링 도구를 사용합니다.
- **JVM 튜닝**: JVM 옵션을 조정해 메모리 관리 방식을 최적화합니다. 예를 들어, 가비지 컬렉션(GC) 설정을 조정하거나 힙 메모리 크기를 조절하는 것이 일반적인 최적화 전략입니다.

### **결론**
실무에서는 스택 메모리 최적화보다 전체적인 메모리 관리와 성능 최적화에 더 중점을 둡니다. 스택 메모리에서의 최적화는 일반적으로 큰 이점을 제공하지 않으며, 대신 힙 메모리 관리와 객체 생성을 줄이는 것이 더 중요한 최적화 대상입니다. 성능 문제는 대부분 메모리 관리나 I/O, 네트워크 대기 시간, 알고리즘 효율성 등에서 발생하므로, 이러한 부분에 더 중점을 두는 것이 좋습니다.
