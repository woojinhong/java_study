## 1. 자료구조(Data Structure)
---
<img src="https://github.com/user-attachments/assets/2b002020-ebdd-4003-b204-ee643fb8b598" alt="JDK Architecture Diagram" width="70%">

<p>출처:(EXCALIDRAW.COM 활용 직접 작성)</p>
<br><br>

### 1.1. 자료구조의 역사
---
자료구조란 데이터 저장과 그에따른 효율적인 계산을 가능하게 하는 기본적인 개념입니다. 
- **1940년 이전**
  - 고대 그리스와 이집트 수학자들이 수치 데이터를 다루기 위한 기본 자료구조 개념을 연구 예) **유클리드** 최대공약수를 찾는 알고리즘.
  - 데이터 관리의 초기 형태는 표와 차트로 정리

- **1940년:** 군사용 목적의 최조 현대 컴퓨터 애니악(ENIAC)의 등장과 함께 대용량 데이터 처리를 위한 연구를 지속
  -  기본적인 자료구조 배열(Array)와 행렬(Matrix) 사용

- **1950년:** 컴퓨터 발전에 따라 복잡한 자료구조 리스트(List)와 큐(Queue) 등장
  - 1956년: **폴린 루터(Pauline Rutheford)** 메모리 상에 연속된 데이터 저장법에 대한 개념을 정립, 리스트 발전 기여
  - 같은 시기 스택(Stack)과 큐(Queue) 등장

- **1960~1970년:** **도널드 커누스(Donald Knuth)**의 저서 **"The Art of Computer Programming"** 수많은 자료구조와 알고리즘 체계화
  - **링크드 리스트(Linked List):** 동적 메모리 할당 위한 자료구조로 이전의 자료구조의 고정된 크기 문제를 해결함
  - **트리(Tree):** 계층적인 데이터 저장, 특히 이진 트리(Binary Tree)는 효율적인 탐색과 정렬 기능하는 알고리즘 기초
  - **힙(Heap):** 이진 트리 구조 활용해 **우선순의** 큐를 구현해 알고리즘 효율성 증대
  
- **1970년:** 추상화 자료구조(Abstract Data Structure) 개념 도입 데이터와 해당 데이터에 대한 연산 분리
  - **그래프(Graph):** 네트워크 분석, 경로 탐색, 소셜 네트워크 분석
  - **해시 테이블(Hash Table):** 데이터 상수 시간 **(O(1))**에 검색할 수 있는 효율적인 방법 구현

- **1980~1990년:** 객체지향 & 자료구조의 발전
  - 객체지향 프로그래밍이 대두됨에 따라, 자료구조도 주요 구성 요소로 자리 잡음
  - **1980년:** 자료구조와 그를 다루는 함수(METHOD) 개념이 발전 예) 객체를 이용해 데이터 캡슐화 (메서드(add, set, get) + 자료구조) 기능
    - **C++** 의 등장으로 클래스를 이용한 자료구조 구현이 가능해졌으며, 객체지향적 자료구조가 널리 사용되었습니다
    - AVL 트리, 레드-블랙 트리(Red-Black Tree) 같은 균형 트리 자료구조가 이 시기에 연구되었으며, 이는 이진 탐색 트리의 불균형 문제를 해결해 효율적인 탐색과 삽입/삭제가 가능하게 만들었습니다

- **1990년:** 자바 같은 언어에서 컬렉션 프레임워크(Collection Framework) 등장
  - 언어(Language) 내에서 표준 라이브러리로 제공
  - 리스트(List), 스택(Stack), 큐(Queue), 맵(Map), 셋(Set) 등 다양한 자료구조

- **2000년대 이후:** 자료구조 응용
  - 대용량 데이터와 병렬 처리 연구 활발해짐
    - 빅데이터 시대에 대용량 데이터처리가 중요해지면서 분산 자료구조(Distributed Data Structure)와 병렬 처리 자료구조 연구
    - 분산 컴퓨팅 플랫폼 Hadoop 과 Spark를 활용해 자료구조를 클러스터 환경에서 효율적으로 관리하는 방식을 발전시켰습니다.
    - 트라이(Trie), B-트리(B-tree), Ternary Search Tree등 대용량 데이터 효율적으로 다루기 위한 자료구조 연구

  - 실시간 데이터 처리를 위해 빠른 접근이 가능한 힙(Heap), 해시맵(HashMap) 사용량 급증
  - 머신러닝과 AI 발전에 따라 특수 자료구조(KD-Tree, R-Tree) 연구및 응용


### 1.1. 자료구조 종류
---

- **1.1.1.Array(배열)**

같은 타입의 데이터를 연속된 메모리 공간에 저장하는 자료구조입니다. 컴파일 시점에 정해진 크기만큼의 메모리 공간을 할당받으며, 불변. (불변이란 런타임시에 배열의 길이를 바꿀 수 없음)
 ```
array1 = new int[10]; // 새로운 배열로 재할당하는 것은 가능
array1.length = 10; // 오류 발생: 배열의 길이는 final 속성이므로 직접 수정할 수 없음
  ```
**궁금한 점:** 이를 보완한 ArrayList와 같은 동적 할당이 모든 Array의 단점을 보완하는데 왜 굳이 final 까지 속성으로 걸어주며 사용하는걸까?
  - 성능: 배열은 메모리를 연속적으로 할당하기 때문에 접근 속도가 빠릅니다. 성능이 중요한 상황에서는 배열이 유리할 수 있습니다. 배열의 크기가 고정되어 있다는 것은 이와 같은 성능 이점을 활용하기 위한 것입니다.

  - 단순성: 배열은 구조가 간단하여, 구현과 사용이 직관적입니다. 배열을 사용할 때는 크기가 고정된 만큼의 메모리를 정확히 알고 있으므로, 메모리 관리를 쉽게 할 수 있습니다.

  - 안정성: 배열의 크기가 변경되지 않도록 하면, 코드에서 배열의 크기를 잘못 조작할 위험이 줄어듭니다. 이로 인해 버그를 방지할 수 있습니다.

  - 기본 자료형 지원: 배열은 기본 자료형을 직접 저장할 수 있으며, ArrayList는 객체로 래핑해야 합니다. 기본 자료형의 배열은 더 효율적으로 메모리를 사용할 수 있습니다.

  - 기타 자료구조와의 호환성: 배열은 다른 자료구조와의 호환성이 좋습니다. 예를 들어, 배열을 다른 알고리즘이나 라이브러리에 쉽게 전달할 수 있습니다.

다 이유가 있다.

  - **특징**
    - 각 원소는 인덱스 통해 접근 가능
    - 메모리 상에 연속적으로 저장
    - **인덱스 0부터** 시작
  - **시간 복잡도**
    - 접근(조회): O(1)(인덱스를 통한 접근) **설명)**  정수형(4BYTE) 배열 기준 2번째 인덱스 접근: 시작주소 0X100 **[0]인덱스** + 4BYTE + 4BYTE = 0X108 **[2]인덱스**  
    - 삽입(삭제): O(n) (중간에 값을 삽입하거나 삭제하는 경우, 나머지 원소를 이동시켜야 함)
      - **궁금**: 배열의 길이는 불변으로 알고 있는데 나머지 원소를 이동시키는 작업은 어떻게 이뤄질까?
        - 삽입의 경우 새로운 배열을 생성해 기존 배열의 요소를 복사 + 새로운 값 복사
        - 삭제의 경우 배열의 길이는 줄이거나 늘리거나 둘다 불가능. 따라서, 마찬가지로 새로운 배열 복사
  - **사용처**
    - 고정된 크기의 데이터를 다룰 때, 자주 사용
    - 주로 임의의 위치에서 빠르게 데이터를 읽어와야 하는 경우 유리 (Arraylist와 마찬가지)
  - **코드 예시**
    - 조회 (0(1))
```
int[] arr = {1, 2, 3, 4, 5};
System.out.println(arr[2]);  // 3
```


- **1.1.2.List(리스트)**
정적 할당을 보완한 List 자료구조. ArrayList (배열 기반) & LinkedList (연결 기반)'

- **ArrayList(배열 리스트)**
  - 배열 기반 과 달리 크기를 동적으로 조절 가능 하지만 메모리가 가득차면 새로운 메모리를 할당해 기존 배열값을 복사하여 사용
    - **궁금:** 기존 배열 리스트 값을 복사하여 사용한다면 배열과 다를게 없는데?
      - 동적 조절: 
      - **ArrayList:** 크기가 자동으로 조절됩니다. 사용자가 새로운 요소를 추가할 때 ArrayList는 내부적으로 배열의 크기가 부족하면 새로운, 더 큰 배열을 생성하고 기존 데이터를 복사합니다. 이 과정은 ArrayList가 관리하며, 사용자는 단순히 요소를 추가하기만 하면 됩니다.
      - **Array:** 사용자가 명시적으로 크기를 설정해야 하며, 크기를 변경하려면 새로운 배열을 생성하고 데이터를 수동으로 복사해야 합니다. 배열은 고정된 크기 때문에 중간에 요소를 삽입하거나 삭제할 경우, 사용자 본인이 새 배열을 만들어야 합니다.
      - 성능:
      - ArrayList는 동적 배열의 성질로 인해 평균적으로 O(1)의 시간 복잡도로 요소를 추가할 수 있지만, 배열이 가득 찼을 때는 O(n) 시간이 걸리는 오버헤드가 발생합니다. 
      - Array는 특정 인덱스에 요소를 추가하거나 삭제할 때 항상 O(n)의 시간 복잡도가 발생합니다.
  - **시간 복잡도**
    - 접근: O(1)
    - 삽입/삭제: O(n) (중간에 삽입/삭제 시)
      - **궁금**: 왜 삽입 시 O(n)의 시간 복잡도가 항상 발생하는거일까? 메모리 상에 최대로 저장할 공간이 남아 있지 않을 시만 O(n) 오버헤드 발생 아닌가?
        - 요소 추가:
        - 일반적인 경우: ArrayList에 요소를 추가하는 것은 평균적으로 O(1)입니다. 이는 새로운 요소를 배열의 끝에 추가하는 것이기 때문입니다. 배열의 끝에 추가할 때는 기존 요소를 이동할 필요가 없으므로 빠르게 수행됩니다. 
        - 배열이 가득 찬 경우: 만약 배열의 크기가 가득 차 있으면, ArrayList는 더 큰 배열을 새로 할당하고 기존 데이터를 복사해야 합니다. 이 과정은 O(n)의 시간 복잡도가 걸립니다. 하지만 이런 경우는 드물기 때문에, 전체적인 평균 시간 복잡도는 O(1)로 평가됩니다. 
          - 요소 삭제 및 중간 삽입:
          - 요소를 삭제하거나 중간에 삽입할 경우는 O(n)입니다. 이때는 삭제한 요소 이후의 모든 요소를 한 칸씩 이동시켜야 하기 때문입니다. 이 과정은 배열의 크기와 상관없이 항상 요소 수에 비례하여 시간이 소요됩니다. 
          - **요약**
            - 삽입:
            - 평균적으로 O(1): 배열의 끝에 추가하는 경우. 
            - O(n): 배열이 가득 차서 새로운 배열을 할당하거나, 중간에 요소를 삽입할 경우. 
            - 삭제:
            - O(n): 삭제할 요소 이후의 모든 요소를 이동시켜야 하기 때문.
          - 고로 중간에 삽입 삭제 시에만 요소들의 이동 시간 때문에 O(n) 하지만 맨 마지막에 삽입 시 O(1)복잡도
    
    - **궁금점 2:**  arraylist 는 해당 인덱스 삭제할때 삭제는 O(1)이지만 그 뒤에 값 이 전부 하나씩 비워진 곳을 이동을 해야해서 O(n)인건가? 인덱스 삭제는 O(1)이고 이걸 통합해서 O(n)이라고 칭하는지
      - 맞아용!~
      - 삭제 자체는 O(1)로 가능하지만, 요소 이동으로 인해 전체 시간 복잡도가 O(n)으로 간주됩니다.
        따라서: ArrayList에서 특정 인덱스를 삭제할 때는 O(n)이라고 표현합니다.
    
    - **코드 예시**
```
List<Integer> arrayList = new ArrayList<>();
arrayList.add(10);  // 끝에 추가
arrayList.add(20);  
System.out.println(arrayList.get(1));  // 20
```

- **LinkedList(연결 리스트)**
  - 각 노드가 데이터와 다음 노드에 대한 참조(포인터)를 가지고 있는 구조입니다. 노드를 연결해 리스트를 이루고 있기 때문에 삽입과 삭제가 빠릅니다.
  - **시간 복잡도**
    - 접근(조회): O(n) 연결된 노드를 순차적으로 탐색해야 함
      - **궁금:** 마지막 노드에 접근(조회)할 시 마지막 메서드를 먼저 조회하는 메서드가 따로 없는지?
        - 응 없습니다. 첫번쨰 노드(헤드 노드)에 접근 -> 다음 노드 이동 -> 마지막 노드 도달할 때까지 이동 -> 마지막 노드 다음 노드에 대한 참조가 null인 노드가 마지막임
    - **삽입/삭제:** O(1) (특정 위치에서 삽입/삭제 시)
      - **궁금:** 노드 조회하는 법이 순차적으로 처음 노드부터 조회해야하면 삭제 삽입도 특정 노드를 먼저 접근을 하려면 노드가 처음부터 접근해야해서 O(n) 아닌가?
        - 따라서, deque[2].remove()와 같이 특정 노드를 알고 있다면 O(1)로 처리할 수 있습니다. 반면, 일반적으로 LinkedList에서 노드를 찾는 것은 O(n)입니다.
        - 예를 들어, deque.get(2)와 같은 접근은 O(n)입니다
  - **사용처**
    - 데이터의 삽입과 삭제가 빈번하게 발생하는 경우 유리합니다. 
    - 데이터를 순차적으로 접근해야 할 때.

  - *코드 예시*
```
List<Integer> linkedList = new LinkedList<>();
linkedList.add(10);  // 끝에 추가
linkedList.add(0, 5);  // 맨 앞에 추가
System.out.println(linkedList.get(0));  // 5
```





